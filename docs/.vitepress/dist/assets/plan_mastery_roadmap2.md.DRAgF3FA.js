import{_ as a,c as i,o as r,ae as t}from"./chunks/framework.ZmT4Iwzr.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"plan/mastery_roadmap2.md","filePath":"plan/mastery_roadmap2.md"}'),n={name:"plan/mastery_roadmap2.md"};function l(o,e,s,c,d,u){return r(),i("div",null,[...e[0]||(e[0]=[t('<h2 id="ğŸ§ -c-advanced-language-features" tabindex="-1">ğŸ§  <strong>C# Advanced Language Features</strong> <a class="header-anchor" href="#ğŸ§ -c-advanced-language-features" aria-label="Permalink to &quot;ğŸ§  **C# Advanced Language Features**&quot;">â€‹</a></h2><h3 id="deep-dive-topics" tabindex="-1">Deep Dive Topics: <a class="header-anchor" href="#deep-dive-topics" aria-label="Permalink to &quot;Deep Dive Topics:&quot;">â€‹</a></h3><ul><li><code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code>, and stackalloc</li><li><code>ref</code>, <code>in</code>, <code>out</code> and <code>ref struct</code> types</li><li>Nullable reference types and context (<code>#nullable enable</code>)</li><li>Source Generators &amp; Incremental Generators</li><li>Unsafe code and pointers</li><li>Advanced delegates: covariance, contravariance</li><li>Custom attributes and reflection</li><li>Expression trees and dynamic code generation</li></ul><hr><h2 id="ğŸš€-net-internals" tabindex="-1">ğŸš€ <strong>.NET Internals</strong> <a class="header-anchor" href="#ğŸš€-net-internals" aria-label="Permalink to &quot;ğŸš€ **.NET Internals**&quot;">â€‹</a></h2><h3 id="dive-into" tabindex="-1">Dive into: <a class="header-anchor" href="#dive-into" aria-label="Permalink to &quot;Dive into:&quot;">â€‹</a></h3><ul><li><p><strong>CLR internals</strong>:</p><ul><li>JIT compilation and tiered compilation</li><li>Garbage Collection (GC generations, large object heap)</li><li>Value types vs. reference types: memory layout</li></ul></li><li><p><strong>Assemblies and IL (Intermediate Language)</strong>:</p><ul><li>Use <code>ildasm</code>, <code>ILSpy</code>, or <code>dnSpy</code></li></ul></li><li><p><strong>AppDomains and Assembly loading (older but useful knowledge)</strong></p></li></ul><hr><h2 id="ğŸ“¦-advanced-net-libraries-apis" tabindex="-1">ğŸ“¦ <strong>Advanced .NET Libraries &amp; APIs</strong> <a class="header-anchor" href="#ğŸ“¦-advanced-net-libraries-apis" aria-label="Permalink to &quot;ğŸ“¦ **Advanced .NET Libraries &amp; APIs**&quot;">â€‹</a></h2><ul><li>System.IO.Pipelines for high-performance streaming</li><li>System.Threading.Channels</li><li><code>System.Buffers</code>, <code>ArrayPool&lt;T&gt;</code>, <code>MemoryPool&lt;T&gt;</code></li><li><code>System.Text.Json</code> vs. Newtonsoft.Json â€” performance tuning</li><li>Interop with native code: P/Invoke and <code>DllImport</code></li></ul><hr><h2 id="ğŸŒ-asp-net-core-advanced-topics" tabindex="-1">ğŸŒ <strong>ASP.NET Core Advanced Topics</strong> <a class="header-anchor" href="#ğŸŒ-asp-net-core-advanced-topics" aria-label="Permalink to &quot;ğŸŒ **ASP.NET Core Advanced Topics**&quot;">â€‹</a></h2><ul><li>Minimal APIs vs. Controllers</li><li>Dependency Injection (DI) internals</li><li>Middleware pipeline â€” custom middleware</li><li>Filters (action, resource, exception)</li><li>Authentication/Authorization: JWT, OAuth, IdentityServer</li><li>SignalR (real-time communication)</li><li>gRPC in .NET</li><li>Advanced model binding &amp; validation customization</li><li>Performance tuning with caching, compression, and async streams</li></ul><hr><h2 id="ğŸ§±-design-architecture" tabindex="-1">ğŸ§± <strong>Design &amp; Architecture</strong> <a class="header-anchor" href="#ğŸ§±-design-architecture" aria-label="Permalink to &quot;ğŸ§± **Design &amp; Architecture**&quot;">â€‹</a></h2><ul><li>SOLID, DRY, KISS, and clean architecture</li><li>DDD (Domain-Driven Design)</li><li>Onion architecture</li><li>Event sourcing vs. CQRS</li><li>Repository &amp; Unit of Work (and when to avoid them)</li><li>MediatR and pipeline behaviors</li></ul><hr><h2 id="âš™ï¸-tools-practices" tabindex="-1">âš™ï¸ <strong>Tools &amp; Practices</strong> <a class="header-anchor" href="#âš™ï¸-tools-practices" aria-label="Permalink to &quot;âš™ï¸ **Tools &amp; Practices**&quot;">â€‹</a></h2><ul><li>BenchmarkDotNet for performance benchmarking</li><li>Roslyn analyzers and writing custom analyzers</li><li>Advanced LINQ queries and performance implications</li><li>Custom build tasks and MSBuild tricks</li><li>Source generators and analyzers</li><li>Diagnostics: PerfView, dotMemory, dotTrace</li></ul><hr><h2 id="ğŸ§ª-testing-and-reliability" tabindex="-1">ğŸ§ª <strong>Testing and Reliability</strong> <a class="header-anchor" href="#ğŸ§ª-testing-and-reliability" aria-label="Permalink to &quot;ğŸ§ª **Testing and Reliability**&quot;">â€‹</a></h2><ul><li>Advanced xUnit, NUnit, and MSTest features</li><li>FluentAssertions and AutoFixture</li><li>Mocking with Moq/NSubstitute/JustMock</li><li>Integration testing with TestServer and WebApplicationFactory</li><li>Contract testing with Pact</li></ul><hr><h2 id="ğŸ”„-asynchronous-programming" tabindex="-1">ğŸ”„ <strong>Asynchronous Programming</strong> <a class="header-anchor" href="#ğŸ”„-asynchronous-programming" aria-label="Permalink to &quot;ğŸ”„ **Asynchronous Programming**&quot;">â€‹</a></h2><ul><li>ValueTask vs Task</li><li>async/await deep internals</li><li>SynchronizationContext and ConfigureAwait</li><li>Channels, Pipelines, and reactive streams</li></ul><hr><h2 id="ğŸ› ï¸-modern-app-ecosystem" tabindex="-1">ğŸ› ï¸ <strong>Modern App Ecosystem</strong> <a class="header-anchor" href="#ğŸ› ï¸-modern-app-ecosystem" aria-label="Permalink to &quot;ğŸ› ï¸ **Modern App Ecosystem**&quot;">â€‹</a></h2><ul><li>Blazor (WebAssembly and Server)</li><li>MAUI (cross-platform desktop/mobile)</li><li>Minimal APIs and microservice design</li><li>Orleans (virtual actors and distributed systems)</li><li>Akka.NET and actor-based concurrency</li></ul><hr><h2 id="ğŸ“¦-nuget-packaging" tabindex="-1">ğŸ“¦ <strong>NuGet &amp; Packaging</strong> <a class="header-anchor" href="#ğŸ“¦-nuget-packaging" aria-label="Permalink to &quot;ğŸ“¦ **NuGet &amp; Packaging**&quot;">â€‹</a></h2><ul><li>Creating reusable NuGet packages</li><li>Targeting multiple frameworks</li><li>Managing transitive dependencies</li></ul><hr><h2 id="ğŸ“Š-diagnostics-performance" tabindex="-1">ğŸ“Š <strong>Diagnostics &amp; Performance</strong> <a class="header-anchor" href="#ğŸ“Š-diagnostics-performance" aria-label="Permalink to &quot;ğŸ“Š **Diagnostics &amp; Performance**&quot;">â€‹</a></h2><ul><li>Performance counters, ETW, and EventSource</li><li>Logging frameworks: Serilog, NLog, etc.</li><li>OpenTelemetry for distributed tracing</li><li>Memory leak analysis</li></ul><hr><h2 id="ğŸ§°-devops-ci-cd" tabindex="-1">ğŸ§° <strong>DevOps &amp; CI/CD</strong> <a class="header-anchor" href="#ğŸ§°-devops-ci-cd" aria-label="Permalink to &quot;ğŸ§° **DevOps &amp; CI/CD**&quot;">â€‹</a></h2><ul><li>GitHub Actions / Azure DevOps pipelines</li><li>Dockerize ASP.NET Core apps</li><li>Kubernetes basics for .NET deployments</li><li>Infrastructure as Code with Terraform or Bicep</li></ul><hr><h2 id="ğŸ“š-study-materials-practice" tabindex="-1">ğŸ“š <strong>Study Materials &amp; Practice</strong> <a class="header-anchor" href="#ğŸ“š-study-materials-practice" aria-label="Permalink to &quot;ğŸ“š **Study Materials &amp; Practice**&quot;">â€‹</a></h2><ul><li><p><strong>Books</strong>:</p><ul><li><em>CLR via C#</em> by Jeffrey Richter</li><li><em>C# in Depth</em> by Jon Skeet</li><li><em>The Art of Unit Testing</em> by Roy Osherove</li><li><em>Pro ASP.NET Core</em> by Adam Freeman</li></ul></li><li><p><strong>Practice</strong>:</p><ul><li>Open source contributions</li><li>Write your own performance-critical libraries</li><li>Build and benchmark microservices</li></ul></li></ul><hr>',41)])])}const h=a(n,[["render",l]]);export{p as __pageData,h as default};
